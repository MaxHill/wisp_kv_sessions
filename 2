import birl
import gleam/dict.{type Dict}
import gleam/dynamic.{type Decoder}
import gleam/io
import gleam/json.{type Json}
import gleam/option.{type Option}
import gleam/result
import wisp

const cookie_name = "SESSION_COOKIE"

pub type SessionId =
  String

pub type Key =
  String

pub type Session {
  Session(id: SessionId, expiry: birl.Time, data: Dict(String, Json))
}

pub type SessionError {
  UnknownError
  NoSessionCookieError
}

pub type SessionStore {
  SessionStore(
    get_session: fn(SessionId) -> Session,
    get: fn(SessionId, Key) -> Option(Result(String, SessionError)),
    set: fn(SessionId, Key, Json) -> Result(Session, SessionError),
    delete: fn(SessionId) -> Result(Nil, SessionError),
  )
}

/// Get data from session by key
///
pub fn get(
  store: SessionStore,
  req: wisp.Request,
  key: Key,
  decoder: Decoder(data),
) -> data {
  todo
}

/// Set data in session by key
///
pub fn set(
  store: SessionStore,
  req: wisp.Request,
  key: Key,
  data: data,
  encoder: fn(data) -> Json,
) {
  case get_session_id(req) {
    Ok(id) -> {
      io.print(id)
      Ok(Session(id: "tbd", expiry: birl.now(), data: dict.new()))
    }
    Error(e) -> {
      io.print("NoSessionCookieError")
      Error(e)
    }
  }
}

/// Remove session
pub fn delete(store: SessionStore, req: wisp.Request) {
  todo
}

fn get_session_id(req: wisp.Request) {
  wisp.get_cookie(req, cookie_name, wisp.Signed)
  |> result.replace_error(NoSessionCookieError)
}

fn set_session_cookie(req: wisp.Request, session: Session) {
  todo
}

// Utils
import gleam/bit_array
import gleam/crypto
import gleam/string

/// Generate a random string of the given length.
///
fn random_string(length: Int) -> String {
  crypto.strong_random_bytes(length)
  |> bit_array.base64_url_encode(False)
  |> string.slice(0, length)
}
